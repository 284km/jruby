
/*
    private List<IR_Instr> getSimpleLinearizedList()
    {
        // Linearize the basic blocks of the cfg!
        // This is a simple linearization -- nothing fancy
        // To break cycles, we assume that a cfg edge where the target BB id is 
        // smaller than the source BB id is a loop back edge.
        BasicBlock root = getEntryBB();
        BitSet bbSet = new BitSet(1+getMaxNodeID());
        bbSet.set(root.getID());
        List<IR_Instr> linearizedList = new ArrayList<IR_Instr>();
        Stack<BasicBlock> stack = new Stack<BasicBlock>();
        stack.push(root);
        while (!stack.empty()) {
            BasicBlock b = stack.pop();

            // check if all parents of 'b' have been processed
            boolean allParentsDone = true;
            for (CFG_Edge e: _cfg.incomingEdgesOf(b)) {
                BasicBlock src = e._src;
                int srcID = src.getID();
                if (!bbSet.get(srcID)) {
                    allParentsDone = false;
                    break;
                }
            }

            // add b's instructions to the linearized list
            if (allParentsDone) {
                List<IR_Instr> bis = b.getInstrs();
                linearizedList.append(bis);
                bbSet.set(b.getID());

                // Find the basic block that is the target of the 'taken' branch
                int n = bis.size();
                IR_Instr lastInstr = bis.get(n-1);
                BasicBlock takenBlock = null;
                if (lastInstr instanceof BRANCH_Instr)
                    takenBlk = _bbMap.get(((BRANCH_Instr)lastInstr).getJumpTarget());

                // Push the taken block onto the stack first so that it gets processed last!
                if ((takenBlock != null) && !bbSet.get(takenBlock.getID()))
                    stack.push(takenBlock);

                // Push rest of the basic blocks in any arbitrary order
                for (CFG_Edge e: _cfg.outgoingEdgesOf(b)) {
                    BasicBlock x = e._dst;
                    if (x != takenBlock)
                        stack.push(x);
                }
            }
        }
    }

    public List<IR_Instr> getInstrs()
    {
        return getSimpleLinearizedList();
    }

    public Set<Variable> usedLocalVarsFromClosures() {
		  if (_usedLocalVars == null) setUpUseDefLocalVarMaps();
        HashSet vs = new HashSet();
        for (IRClosure cl: getScope().getClosures()) {
            CFG c = cl.getCFG();
            vs.addAll(c._usedLocalVars);
            vs.addAll(c.usedLocalVarsFromClosures());
        }

        return vs;
    }

    public Set<Variable> definedLocalVarsFromClosures() {
		  if (_definedLocalVars == null) setUpUseDefLocalVarMaps();
        HashSet vs = new HashSet();
        for (IRClosure cl: getScope().getClosures()) {
            CFG c = cl.getCFG();
            vs.addAll(c._definedLocalVars);
            vs.addAll(c.definedLocalVarsFromClosures());
        }

        return vs;
    }
*/
