%package "org.jruby.ir.persistence";

%import "org.jruby.ir.operands.Array";
%import "org.jruby.ir.operands.CompoundString";
%import "org.jruby.ir.operands.Operand";
%import "org.jruby.ir.persistence.IROperandFactory";

%import "org.jruby.util.KCode";
%import "org.jruby.util.RegexpOptions";

%class "PersistedIRParser";

%terminals STRING_LITERAL, SYMBOL_LITERAL;
%terminals EOLN;
%terminals LBRACK, RBRACK;
%terminals DOT, SEMICOLON, COMMA, LBRACE, RBRACE, LPAREN, RPAREN, GT, LT;
%terminals ARRAY_MARKER, BIGNUM_MARKER, COMPOUND_STRING_MARKER, FIXNUM_MARKER, FLOAT_MARKER;
%terminals ASTERISK, COLON, DOLLAR, HASH, PERCENT;
%terminals SVALUE_MARKER;
%terminals ARGS_PUSH_MARKER, ARGS_CAT_MARKER;
%terminals SCOPE_MARKER, MODULE_MARKER;
%terminals REGEXP_MARKER, BAR, REGEXP_OPTIONS_MARKER, KCODE_MARKER, ENC_NODE, EXPECTED, FIXED, IGNORECASE, JAVA, KCODE_DEFAULT, LITERAL, MULTILINE, ONCE;
%terminals RANGE_MARKER, EXCLUSIVE, INCLUSIVE;
%terminals UNKNOWN_SUPER_TARGET, OBJECT_CLASS, SELF, STANDARD_ERROR, UNDEFINED_VALUE, UNEXECUTABLE_NIL;
%terminals NIL, TRUE, FALSE;
%terminals KCODE_NIL, KCODE_NONE, KCODE_UTF8, KCODE_SJIS, KCODE_EUC;
%terminals IDENTIFIER;

%typeof STRING_LITERAL, IDENTIFIER, SYMBOL_LITERAL, BIGNUM_LITERAL, FIXNUM_LITERAL, FLOAT_LITERAL = "String";
%typeof ARRAY = "Array";
%typeof operand, literal = "Operand";
%typeof compound_string  = "CompoundString";
%typeof kcode = "KCode";
%typeof regexp_options = "RegexpOptions";

operand
    =   literal
    |   array
    |   as_string
// attribute           -  no toString, strange operand in general
// backtick_string     -  no toString
    |   compound_array
// compound_string     -  encoding is not persisted
// current_scope       -  needs IRScope as parameter to constructor
// dynamic_symbol      -  needs compound_string
// hash                -  no toString
// ir_exception        -  there is only static final instances of exceptions, constructor is protected
// label               -  may be arbitrary string, not IDENTIFIER
    |   method_handle
    |   object_class
    |   range
    |   reference
    |   regexp
// scope_module        -  needs IRScope as parameter to constructor
    |   splat
    |   standard_error
    |   svalue
    |   undefined_value
    |   variable
// wrapped_ir_closure  -  call IRClosure#toString() which is not enough
    ;
    
literal 
    =   immutable_literal
	|   string_literal
	;
	
string_literal
    =   STRING_LITERAL.s                {: return new Symbol( IROperandFactory.INSTANCE.createStringLiteral(s)); :}
    ;
	
immutable_literal
    =   BIGNUM_LITERAL.b BIGNUM_MARKER  {: return new Symbol( IROperandFactory.INSTANCE.createBignum(b) ); :}
    |   FIXNUM_LITERAL.n FIXNUM_MARKER  {: return new Symbol( IROperandFactory.INSTANCE.createFixnum(n) ); :}
	|	FLOAT_LITERAL.f FLOAT_MARKER    {: return new Symbol( IROperandFactory.INSTANCE.createFloat(f) ); :}
	|	NIL                             {: return new Symbol( IROperandFactory.INSTANCE.createNil() ); :}
	|	UNEXECUTABLE_NIL                {: return new Symbol( IROperandFactory.INSTANCE.createUnexecutableNil() ); :}
	|   TRUE                            {: return new Symbol( IROperandFactory.INSTANCE.createTrueLiteral() ); :}
	|   FALSE                           {: return new Symbol( IROperandFactory.INSTANCE.createFalseLiteral() ); :}
	;

array
    =   ARRAY_MARKER LBRACK array_elements? RBRACK
    ;
    
array_elements
    =   operand
    |   array_elements COMMA operand
    
as_string
    =   DOLLAR LBRACE operand.o RBRACE  {: return new Symbol( IROperandFactory.INSTANCE.createAsString(o) ); :}
    ;
    
compound_array
    =   ARGS_PUSH_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsPush(a1, a2) ); :}
    |   ARGS_CAT_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsCat(a1, a2) ); :}
    ;

// scope needed    
//current_scope
//    =   SCOPE_MARKER LT IDENTIFIER.name GT
//                                        {: return new Symbol( IROperandFactory.INSTANCE.createCurrentScope(scope, name) ); :}
//    ;
    
//dynamic_symbol
//    = COLON compound_string.symbol_name   {: return new Symbol( IROperandFactory.INSTANCE.createDynamicSymbol(symbol_name) ); :} 
//    ;
//ir_exception
//    =   IDENTIFIER
       
//label
//    =   IDENTIFIER

method_handle
    =   LT operand.receiver DOT operand.methodName GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createMethodHandle(methodName, receiver) ); :}
    ;

object_class
    =   OBJECT_CLASS                    {: return new Symbol( IROperandFactory.INSTANCE.createObjectClass() ); :}
    ;
 
range
    =   exclusive_range
    |   inclusive_range
    ;
   
exclusive_range
    =   operand.b EXCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createExclusiveRange(b.value, e.value) ); :}
    ;
   
inclusive_range
    =   operand.b INCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createInclusiveRange(b.value, e.value) ); :}
    ;
    
reference
    =   backref
    |   global_variable
    |   meth_addr
    |   nth_ref
    |   symbol
    ;
    
backref
    =   DOLLAR IDENTIFIER.char          {: return new Symbol( IROperandFactory.INSTANCE.createBackref(char) ); :}
    ;
    
global_variable
    =   IDENTIFIER.name                 {: return new Symbol( IROperandFactory.INSTANCE.createGlobalVariable(name) ); :}
    ;
    
meth_addr
    =   IDENTIFIER.name                 {: return new Symbol( IROperandFactory.INSTANCE.createMethAddr(name) ); :}
    ;
    
nth_ref
    =   DOLLAR FIXNUM_LITERAL.num       {: return new Symbol( IROperandFactory.INSTANCE.createNthRef(num) ); :}
    ;
    
symbol
    =   COLON SYMBOL_LITERAL.s          {: return new Symbol( IROperandFactory.INSTANCE.createSymbol(s) ); :}	
    ;
    
regexp
    =   REGEXP_MARKER BAR operand.operand BAR regexp_options.options
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexp(operand, options) ); :}	
    ;

// not finished
regexp_options
    =   REGEXP_OPTIONS_MARKER LPAREN KCODE_MARKER kcode COMMA? ENC_NODE? COMMA? EXPECTED? COMMA? FIXED? COMMA? IGNORECASE? COMMA? JAVA? COMMA? KCODE_DEFAULT? COMMA? LITERAL? COMMA? MULTILINE? COMMA? ONCE? RPAREN
    ;
    
kcode
    =   KCODE_NIL                       {: return new Symbol( KCode.NIL ); :}
    |   KCODE_NONE                      {: return new Symbol( KCode.NONE ); :}
    |   KCODE_UTF8                      {: return new Symbol( KCode.UTF8 ); :}
    |   KCODE_SJIS                      {: return new Symbol( KCode.SJIS ); :}
    |   KCODE_EUC                       {: return new Symbol( KCode.EUC ); :}
    ;

// string, not IDENTIFIER
//scope_module
//    =   MODULE_MARKER LT IDENTIFIER.name GT
//    ;

splat
    =   ASTERISK operand.array          {: return new Symbol( IROperandFactory.INSTANCE.createSplat(array) ); :}
    ;
    
standard_error
    =   STANDARD_ERROR                  {: return new Symbol( IROperandFactory.INSTANCE.createStandardError() ); :}
    ;
    
svalue
    =   SVALUE_MARKER LBRACE operand.array RBRACE
                                        {: return new Symbol( IROperandFactory.INSTANCE.createSValue(array) ); :}
    ;
    
undefined_value
    =   UNDEFINED_VALUE                 {: return new Symbol( IROperandFactory.INSTANCE.createUndefininedValue() ); :}
	;
	
variable
    =   local_variable
    |   temprorary_variable
    ;
    
local_variable
    =   SELF                            {: return new Symbol( IROperandFactory.INSTANCE.createSelf() ); :}
    |   LT IDENTIFIER.id LPAREN FIXNUM_LITERAL.scopeDepth COLON FIXNUM_LITERAL.offset  RPAREN GT // not implemented!    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createClosureLocalVariable(scope, id, scopeDepth, offset) ); :}
    |   IDENTIFIER.id LPAREN FIXNUM_LITERAL.scopeDepth COLON FIXNUM_LITERAL.offset  RPAREN 
                                        {: return new Symbol( IROperandFactory.INSTANCE.createLocalVariable(id, scopeDepth, offset) ); :}
    ;

temprorary_variable // not implemented!
    =   PERCENT IDENTIFIER.id           {: return IROperandFactory.INSTANCE.createTemproraryVariable(id); :}
        temporary_closure_variable
    ;

temporary_closure_variable
    :   PERCENT IDENTIFIER.id
    ;
%package "org.jruby.ir.persistence";

%import "org.jruby.ir.instructions.Instr";
%import "org.jruby.ir.operands.Array";
%import "org.jruby.ir.operands.CompoundString";
%import "org.jruby.ir.operands.Operand";
%import "org.jruby.ir.operands.Variable";
%import "org.jruby.ir.persistence.IROperandFactory";

%import "org.jruby.util.KCode";
%import "org.jruby.util.RegexpOptions";

%class "PersistedIRParser";

%terminals STRING_LITERAL, SYMBOL_LITERAL;
%terminals EOLN;
%terminals ALIAS, BLOCK_GIVEN;
%terminals EQ;
%terminals LBRACK, RBRACK;
%terminals DOT, SEMICOLON, COMMA, LBRACE, RBRACE, LPAREN, RPAREN, GT, LT;
%terminals ARRAY_MARKER, BIGNUM_MARKER, COMPOUND_STRING_MARKER, FIXNUM_MARKER, FLOAT_MARKER;
%terminals ASTERISK, COLON, DOLLAR, HASH, PERCENT;
%terminals SVALUE_MARKER;
%terminals ARGS_PUSH_MARKER, ARGS_CAT_MARKER;
%terminals SCOPE_MARKER, MODULE_MARKER;
%terminals REGEXP_MARKER, BAR, REGEXP_OPTIONS_MARKER, KCODE_MARKER, ENC_NODE, EXPECTED, FIXED, IGNORECASE, JAVA, KCODE_DEFAULT, LITERAL, MULTILINE, ONCE;
%terminals RANGE_MARKER, EXCLUSIVE, INCLUSIVE;
%terminals UNKNOWN_SUPER_TARGET, OBJECT_CLASS, SELF, STANDARD_ERROR, UNDEFINED_VALUE, UNEXECUTABLE_NIL;
%terminals NIL, TRUE, FALSE;
%terminals KCODE_NIL, KCODE_NONE, KCODE_UTF8, KCODE_SJIS, KCODE_EUC;
%terminals IDENTIFIER;

%typeof STRING_LITERAL, IDENTIFIER, SYMBOL_LITERAL, BIGNUM_LITERAL, FIXNUM_LITERAL, FLOAT_LITERAL, branch_name = "String";
%typeof ARRAY = "Array";
%typeof operand, literal = "Operand";
%typeof variable = "Variable";
%typeof compound_string  = "CompoundString";
%typeof kcode = "KCode";
%typeof regexp_options = "RegexpOptions";
%typeof instruction = "Instr";

instructions
    =   instruction EOLN
    |   instructions instruction EOLN
    ;
    
instruction
    =   alias
    |   branch
    |   result
    ;
    
alias
    =   ALIAS LPAREN variable.receiver COMMA operand.newName COMMA operand.oldName RPAREN
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createAlias(receiver, newName, oldName) ); :}
    ;

branch
    =   branch_name.name LPAREN operand.arg1 COMMA (operand.arg2 COMMA)? label.target
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createBranch(name, arg1, arg2, target) ); :}
    ;    
    
branch_name    
    =   "beq" 
    |   "b_false"
    |   "bne"
    |   "b_nil"
    |   "b_true"
    |   "b_undef"
    ;
    
b_eq
    =       
  
result
    =   block_given
    ;
    
block_given
    =   variable.result EQ BLOCK_GIVEN
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createBlockGiven(result) ); :}
    ;

operand
    =   literal
    |   array
    |   as_string
// attribute           -  no toString, strange operand in general
// backtick_string     -  no toString
    |   compound_array
// compound_string     -  encoding is not persisted
// current_scope       -  needs IRScope as parameter to constructor
// dynamic_symbol      -  needs compound_string
// hash                -  no toString
// ir_exception        -  there is only static final instances of exceptions, constructor is protected
// label               -  may be arbitrary string, not IDENTIFIER
    |   method_handle
    |   object_class
    |   range
    |   reference
    |   regexp
// scope_module        -  needs IRScope as parameter to constructor
    |   splat
    |   standard_error
    |   svalue
    |   undefined_value
    |   variable
// wrapped_ir_closure  -  call IRClosure#toString() which is not enough
    ;
    
literal 
    =   immutable_literal
	|   string_literal
	;
	
string_literal
    =   STRING_LITERAL.s                {: return new Symbol( IROperandFactory.INSTANCE.createStringLiteral(s) ); :}
    ;
	
immutable_literal
    =   BIGNUM_LITERAL.b BIGNUM_MARKER  {: return new Symbol( IROperandFactory.INSTANCE.createBignum(b) ); :}
    |   FIXNUM_LITERAL.n FIXNUM_MARKER  {: return new Symbol( IROperandFactory.INSTANCE.createFixnum(n) ); :}
	|	FLOAT_LITERAL.f FLOAT_MARKER    {: return new Symbol( IROperandFactory.INSTANCE.createFloat(f) ); :}
	|	NIL                             {: return new Symbol( IROperandFactory.INSTANCE.createNil() ); :}
	|	UNEXECUTABLE_NIL                {: return new Symbol( IROperandFactory.INSTANCE.createUnexecutableNil() ); :}
	|   TRUE                            {: return new Symbol( IROperandFactory.INSTANCE.createTrueLiteral() ); :}
	|   FALSE                           {: return new Symbol( IROperandFactory.INSTANCE.createFalseLiteral() ); :}
	;

array
    =   ARRAY_MARKER LBRACK array_elements? RBRACK
    ;
    
array_elements
    =   operand
    |   array_elements COMMA operand
    
as_string
    =   DOLLAR LBRACE operand.o RBRACE  {: return new Symbol( IROperandFactory.INSTANCE.createAsString(o) ); :}
    ;
    
compound_array
    =   ARGS_PUSH_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsPush(a1, a2) ); :}
    |   ARGS_CAT_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsCat(a1, a2) ); :}
    ;

// scope needed    
//current_scope
//    =   SCOPE_MARKER LT IDENTIFIER.name GT
//                                        {: return new Symbol( IROperandFactory.INSTANCE.createCurrentScope(scope, name) ); :}
//    ;
    
//dynamic_symbol
//    = COLON compound_string.symbol_name   {: return new Symbol( IROperandFactory.INSTANCE.createDynamicSymbol(symbol_name) ); :} 
//    ;
//ir_exception
//    =   IDENTIFIER
       
//label
//    =   IDENTIFIER

method_handle
    =   LT operand.receiver DOT operand.methodName GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createMethodHandle(methodName, receiver) ); :}
    ;

object_class
    =   OBJECT_CLASS                    {: return new Symbol( IROperandFactory.INSTANCE.createObjectClass() ); :}
    ;
 
range
    =   exclusive_range
    |   inclusive_range
    ;
   
exclusive_range
    =   operand.b EXCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createExclusiveRange(b.value, e.value) ); :}
    ;
   
inclusive_range
    =   operand.b INCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createInclusiveRange(b.value, e.value) ); :}
    ;
    
reference
    =   backref
    |   global_variable
    |   meth_addr
    |   nth_ref
    |   symbol
    ;
    
backref
    =   DOLLAR IDENTIFIER.char          {: return new Symbol( IROperandFactory.INSTANCE.createBackref(char) ); :}
    ;
    
global_variable
    =   IDENTIFIER.name                 {: return new Symbol( IROperandFactory.INSTANCE.createGlobalVariable(name) ); :}
    ;
    
meth_addr
    =   IDENTIFIER.name                 {: return new Symbol( IROperandFactory.INSTANCE.createMethAddr(name) ); :}
    ;
    
nth_ref
    =   DOLLAR FIXNUM_LITERAL.num       {: return new Symbol( IROperandFactory.INSTANCE.createNthRef(num) ); :}
    ;
    
symbol
    =   COLON SYMBOL_LITERAL.s          {: return new Symbol( IROperandFactory.INSTANCE.createSymbol(s) ); :}	
    ;
    
regexp
    =   REGEXP_MARKER BAR operand.operand BAR regexp_options.options
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexp(operand, options) ); :}	
    ;

// not finished
regexp_options
    =   REGEXP_OPTIONS_MARKER LPAREN KCODE_MARKER kcode COMMA? ENC_NODE? COMMA? EXPECTED? COMMA? FIXED? COMMA? IGNORECASE? COMMA? JAVA? COMMA? KCODE_DEFAULT? COMMA? LITERAL? COMMA? MULTILINE? COMMA? ONCE? RPAREN
    ;
    
kcode
    =   KCODE_NIL                       {: return new Symbol( KCode.NIL ); :}
    |   KCODE_NONE                      {: return new Symbol( KCode.NONE ); :}
    |   KCODE_UTF8                      {: return new Symbol( KCode.UTF8 ); :}
    |   KCODE_SJIS                      {: return new Symbol( KCode.SJIS ); :}
    |   KCODE_EUC                       {: return new Symbol( KCode.EUC ); :}
    ;

// string, not IDENTIFIER
//scope_module
//    =   MODULE_MARKER LT IDENTIFIER.name GT
//    ;

splat
    =   ASTERISK operand.array          {: return new Symbol( IROperandFactory.INSTANCE.createSplat(array) ); :}
    ;
    
standard_error
    =   STANDARD_ERROR                  {: return new Symbol( IROperandFactory.INSTANCE.createStandardError() ); :}
    ;
    
svalue
    =   SVALUE_MARKER LBRACE operand.array RBRACE
                                        {: return new Symbol( IROperandFactory.INSTANCE.createSValue(array) ); :}
    ;
    
undefined_value
    =   UNDEFINED_VALUE                 {: return new Symbol( IROperandFactory.INSTANCE.createUndefininedValue() ); :}
	;
	
variable
    =   local_variable
    |   temprorary_variable
    ;
    
local_variable
    =   SELF                            {: return new Symbol( IROperandFactory.INSTANCE.createSelf() ); :}
    |   LT IDENTIFIER.id LPAREN FIXNUM_LITERAL.scopeDepth COLON FIXNUM_LITERAL.offset  RPAREN GT // not implemented!    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createClosureLocalVariable(scope, id, scopeDepth, offset) ); :}
    |   IDENTIFIER.id LPAREN FIXNUM_LITERAL.scopeDepth COLON FIXNUM_LITERAL.offset  RPAREN 
                                        {: return new Symbol( IROperandFactory.INSTANCE.createLocalVariable(id, scopeDepth, offset) ); :}
    ;

temprorary_variable // not implemented!
    =   PERCENT IDENTIFIER.id           {: return IROperandFactory.INSTANCE.createTemproraryVariable(id); :}
        temporary_closure_variable
    ;

temporary_closure_variable
    :   PERCENT IDENTIFIER.id
    ;
%package "org.jruby.ir.persistence";

%import "org.jruby.ir.Operation";

%import "org.jruby.ir.instructions.Instr";
%import "org.jruby.ir.operands.Array";
%import "org.jruby.ir.operands.CompoundString";
%import "org.jruby.ir.operands.Label";
%import "org.jruby.ir.operands.Operand";
%import "org.jruby.ir.operands.Variable";
%import "org.jruby.ir.operands.KeyValuePair";

%import "org.jruby.ir.persistence.IROperandFactory";
%import "org.jruby.ir.persistence.IRScopeBuilder";

%import "org.jruby.runtime.CallType";
%import "org.jruby.util.KCode";
%import "org.jruby.util.RegexpOptions";

%class "PersistedIRParser";

%terminals STRING_LITERAL, SYMBOL_LITERAL, ID, STRING, FIXNUM, FLOAT;
%terminals EOLN;
%terminals EQ;
%terminals DOT, SEMICOLON, COMMA, LBRACE, RBRACE, LPAREN, RPAREN, GT, LT, LBRACK, RBRACK;
%terminals ARRAY_MARKER, ARGS_PUSH_MARKER, ARGS_CAT_MARKER, BIGNUM_MARKER, COMPOUND_STRING_MARKER, FIXNUM_MARKER, FLOAT_MARKER, IREXCEPTION_MARKER, SVALUE_MARKER;
%terminals SCOPE_START_MARKER, SCOPE_MARKER, MODULE_MARKER;
%terminals ASTERISK, GTE, BACKTICK, COLON, DOLLAR, HASH, PERCENT;

// Regexp terminals
%terminals REGEXP_MARKER, BAR, REGEXP_OPTIONS_MARKER, KCODE_MARKER;

// Range markers
%terminals EXCLUSIVE, INCLUSIVE;

// Special types of operands
%terminals UNKNOWN_SUPER_TARGET, OBJECT_CLASS, SELF, STANDARD_ERROR, UNDEFINED_VALUE, UNEXECUTABLE_NIL;
%terminals NIL, TRUE, FALSE;

%typeof STRING_LITERAL, STRING, ID, SYMBOL_LITERAL, FIXNUM, FLOAT, branch_name, regexp_opt_option = "String";
%typeof array_operand = "Array";
%typeof operand = "Operand";
%typeof variable = "Variable";
%typeof compound_string  = "CompoundString";
%typeof kcode = "KCode";
%typeof call_type = "CallType";
%typeof regexp_options = "RegexpOptions";
%typeof instruction = "Instr";
%typeof key_value_pair = "KeyValuePair";
%typeof label = "Label";
%typeof param = "Object";
%typeof operation = "Operation";

%goal scope

scope
    =    SCOPE_START_MARKER LT STRING.name GT 
         instructions.instrs EOLN
                                        {: return new Symbol( IRScopeFactory.INSTANCE.createScope(name, instrs) ); :}
    ;

instructions
    =    instruction EOLN
    |    instructions instruction EOLN
    ;
    
instruction
    =    label_instr   
    |    simple_instr
    |    result_instr
    ;
    
label_instr
    =    label.label COLON              {: return new Symbol( IRInstructionFactory.INSTANCE.createLabel(label) ); :}
    ;

simple_instr
    // only tread poll so far
    =    operation.id                   {: return new Symbol( IRInstructionFactory.INSTANCE.createTreadPoll() ); :}
    // only jump so far
    |    operation label.target         {: return new Symbol( IRInstructionFactory.INSTANCE.createJump(target) ); :}
    |    operation.id LPAREN param_list.list RPAREN
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createInstrWithParams(id, list) ); :}
    ;
    
operation
    =    ID.name                        {: return new Symbol( IRInstructionFactory.INSTANCE.createOpertion(name) ); :}
    
param_list
    =    param
    |    param_list COMMA param
    ;
    
param
    =    operand
    |    FIXNUM.val                     {: return new Symbol( Integer.valueOf(val) ); :}
    |    array
    ;
     
result_instr
    =    variable.var EQ operand.op     {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithOperand(var, op) ); :}
    |    variable.var EQ operation.instr
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithNoParams(var, instr) ); :}
    |    variable EQ operation.instr LPAREN param_list.list RPAREN 
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createReturnInstrWithParams(var, instr, list) ); :}
    // only PutGlobalVarInstr so far
    |    operation.instr LPAREN operand.o1 RPAREN EQ operand.o2
                                        {: return new Symbol( IRInstructionFactory.INSTANCE.createPutGlobalVar(o1, o2) ); :}
    ;

operand
    =   array_operand
    |   array  // hack! it is here only for CallInstr
    |   as_string
    |   backtick_string
    |   compound_array
    |   compound_string
    |   current_scope
    |   dynamic_symbol
    |   hash
    |   immutable_literal
    |   ir_exception
    |   label
    |   method_handle
    |   object_class
    |   range
    |   reference
    |   regexp
    |   scope_module
    |   splat
    |   standard_error
    |   string_literal
    |   svalue
    |   undefined_value
    |   variable
    |   wrapped_ir_closure
    ;
    
array_operand
    =   ARRAY_MARKER array.a            {: return new Symbol( IROperandFactory.INSTANCE.createArray(a.value) ); :}
    ;
    
array
    =   LBRACK array_elements.els? RBRACK
    ;
    
array_elements
    =   operand
    |   array_elements COMMA operand
    ;
    
as_string
    =   DOLLAR LBRACE operand.o RBRACE  {: return new Symbol( IROperandFactory.INSTANCE.createAsString(o) ); :}
    ;
    
backtick_string
    =   BACKTICK array.a BACKTICK       {: return new Symbol( IROperandFactory.INSTANCE.createBacktickString(a) ); :}
    ;
    
compound_array
    =   ARGS_PUSH_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsPush(a1, a2) ); :}
    |   ARGS_CAT_MARKER LBRACK operand.a1 COMMA operand.a2 RBRACK
                                        {: return new Symbol( IROperandFactory.INSTANCE.createArgsCat(a1, a2) ); :}
    ;
  
current_scope
    =   SCOPE_MARKER LT STRING.name GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createCurrentScope(scope, name) ); :}
    ;
    
dynamic_symbol
    =    COLON compound_string.symbol_name
                                        {: return new Symbol( IROperandFactory.INSTANCE.createDynamicSymbol(symbol_name) ); :} 
    ;
    
hash
    =    LBRACE key_value_pairs.pairs? RBRACE
                                        {: return new Symbol( IROperandFactory.INSTANCE.createHash(pairs) ); :}    
    ;
    
key_value_pairs
    =    key_value_pair
    |    key_value_pairs COMMA key_value_pair
    
key_value_pair
    =    operand.key GTE operand.value    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createKeyValuePair(key, value) ); :} 
    ;

immutable_literal
    =   BIGNUM_MARKER FIXNUM.b          {: return new Symbol( IROperandFactory.INSTANCE.createBignum(b) ); :}
    |   FIXNUM_MARKER FIXNUM.n          {: return new Symbol( IROperandFactory.INSTANCE.createFixnum(n) ); :}
	|	FLOAT_MARKER FLOAT.f            {: return new Symbol( IROperandFactory.INSTANCE.createFloat(f) ); :}
	|	NIL                             {: return new Symbol( IROperandFactory.INSTANCE.createNil() ); :}
	|	UNEXECUTABLE_NIL                {: return new Symbol( IROperandFactory.INSTANCE.createUnexecutableNil() ); :}
	|   TRUE                            {: return new Symbol( IROperandFactory.INSTANCE.createTrueLiteral() ); :}
	|   FALSE                           {: return new Symbol( IROperandFactory.INSTANCE.createFalseLiteral() ); :}
	;

ir_exception
    =   IREXCEPTION_MARKER ID.reason    {: return new Symbol( IROperandFactory.INSTANCE.createIRException(reason) ); :}
    ;
       
label
    =   ID.label                        {: return new Symbol( IROperandFactory.INSTANCE.createLabel(label) ); :}

method_handle
    =   LT operand.receiver DOT operand.methodName GT
                                        {: return new Symbol( IROperandFactory.INSTANCE.createMethodHandle(methodName, receiver) ); :}
    ;

object_class
    =   OBJECT_CLASS                    {: return new Symbol( IROperandFactory.INSTANCE.createObjectClass() ); :}
    ;
 
range
    =   exclusive_range
    |   inclusive_range
    ;
   
exclusive_range
    =   operand.b EXCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createExclusiveRange(b, e) ); :}
    ;
   
inclusive_range
    =   operand.b INCLUSIVE operand.e   {: return new Symbol( IROperandFactory.INSTANCE.createInclusiveRange(b, e) ); :}
    ;
    
reference
    =   backref
    |   global_variable
    |   meth_addr
    |   nth_ref
    |   symbol
    ;
    
backref
    =   DOLLAR SYMBOL_LITERAL.char      {: return new Symbol( IROperandFactory.INSTANCE.createBackref(char) ); :}
    ;
    
global_variable
    =   DOLLAR ID.name                  {: return new Symbol( IROperandFactory.INSTANCE.createGlobalVariable(name) ); :}
    ;
    
meth_addr
    =   SYMBOL_LITERAL.name             {: return new Symbol( IROperandFactory.INSTANCE.createMethAddr(name) ); :}
    ;
    
nth_ref
    =   DOLLAR FIXNUM.num               {: return new Symbol( IROperandFactory.INSTANCE.createNthRef(num) ); :}
    ;
    
symbol
    =   COLON SYMBOL_LITERAL.s          {: return new Symbol( IROperandFactory.INSTANCE.createSymbol(s) ); :}	
    ;
    
regexp
    =   REGEXP_MARKER BAR operand.operand BAR regexp_options.options
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexp(operand, options) ); :}	
    ;

regexp_options
    =   REGEXP_OPTIONS_MARKER LPAREN KCODE_MARKER ID.kcode regexp_opt_options.opt? RPAREN
                                        {: return new Symbol( IROperandFactory.INSTANCE.createRegexpOptions(kcode, opt) ); :}
    ;
    
regexp_opt_options
    =  regexp_opt_option
    |  regexp_opt_options regexp_opt_option
    ;
    
regexp_opt_option
    =  COMMA ID.opt
    ;

scope_module
    =   MODULE_MARKER LT STRING.name GT {: return new Symbol( IROperandFactory.INSTANCE.createScopeModule(name) ); :}
    ;

splat
    =   ASTERISK operand.array          {: return new Symbol( IROperandFactory.INSTANCE.createSplat(array) ); :}
    ;
    
standard_error
    =   STANDARD_ERROR                  {: return new Symbol( IROperandFactory.INSTANCE.createStandardError() ); :}
    ;
    
string_literal
    =   STRING_LITERAL.s                {: return new Symbol( IROperandFactory.INSTANCE.createStringLiteral(s) ); :}
    ;
    
svalue
    =   SVALUE_MARKER operand.array
                                        {: return new Symbol( IROperandFactory.INSTANCE.createSValue(array) ); :}
    ;
    
undefined_value
    =   UNDEFINED_VALUE                 {: return new Symbol( IROperandFactory.INSTANCE.createUndefininedValue() ); :}
	;
	
variable
    =   local_variable
    |   temporary_variable
    ;
    
local_variable
    =   SELF                            {: return new Symbol( IROperandFactory.INSTANCE.createSelf() ); :}
    |   LT ID.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.offset  RPAREN GT // not implemented!    
                                        {: return new Symbol( IROperandFactory.INSTANCE.createClosureLocalVariable(scope, id, scopeDepth, offset) ); :}
    |   ID.id LPAREN FIXNUM.scopeDepth COLON FIXNUM.offset  RPAREN 
                                        {: return new Symbol( IROperandFactory.INSTANCE.createLocalVariable(id, scopeDepth, offset) ); :}
    ;

temporary_variable
    =   PERCENT ID.id                   {: return IROperandFactory.INSTANCE.createTemproraryVariable(id); :}
//    |    temporary_closure_variable
    ;

//temporary_closure_variable
//    :   PERCENT ID.id
//    ;
